package net.lshift.javax.management;

import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Map;

import javax.management.MBeanServer;
import javax.management.MBeanServerFactory;
import javax.management.MalformedObjectNameException;
import javax.management.ObjectName;
import javax.management.openmbean.SimpleType;
import javax.naming.Reference;

import net.lshift.javax.naming.NamingHelper;

public class ManagementHelper
{
    private static MBeanServer SERVER = null;

    public static MBeanServer defaultMBeanServer()
    {
        if(SERVER == null) {
            ArrayList servers = MBeanServerFactory.findMBeanServer(null);
            SERVER = servers.isEmpty()
                ? MBeanServerFactory.createMBeanServer()
                : (MBeanServer)servers.get(0);
        }

        return SERVER;
    }

    /**
     * Map from a class name to an SimpleType.
     * Its generated by reflecting on SimpleType, looking for static
     * fields of type SimpleType. Its a map from SimpleType.getClassName()
     * to the instance itself.
     */
    public static final Map<String,SimpleType> SIMPLE_TYPES;
    static {
        Map<String,SimpleType> simpleTypes = new HashMap<String,SimpleType>();
        for(Field field: SimpleType.class.getDeclaredFields()) {
            if((field.getModifiers() & Modifier.STATIC) > 0 &&
               field.getType() == SimpleType.class) {
                try {
                    SimpleType type = (SimpleType)field.get(null);
                    simpleTypes.put(type.getClassName(), type);
                }
                catch(Exception e) {
                    throw new RuntimeException();
                }
            }
        }

        SIMPLE_TYPES = Collections.unmodifiableMap(simpleTypes);
    }

    /**
     * Generate an object name from a domain and javax.naming.Reference.
     * The reference is really a bunch of key value pairs, so if you want
     * to create an MBean for the object your ObjectFactory is about to
     * return, its convenient to use the reference to build the
     * MBean's ObjectName
     * @param domain
     * @param reference
     * @return
     * @throws MalformedObjectNameException
     * @throws NullPointerException
     */
    @SuppressWarnings("unchecked")
    public static ObjectName objectName(String domain, Reference reference)
        throws MalformedObjectNameException, NullPointerException
    {
        Hashtable keyProperties = new Hashtable();
        keyProperties.putAll(NamingHelper.map(reference));
        return new ObjectName(domain, keyProperties);
    }
}
